#!/usr/bin/env python

#
# Author: James Michael Bell, 2014 (jmbell@bcm.edu)
# Copyright (c) 2014 Baylor College of Medicine
#
# This software is issued under a joint BSD/GNU license. You may use the
# source code in this file under either license. However, note that the
# complete EMAN2 and SPARX software packages have some GPL dependencies,
# so you are responsible for compliance with the licenses of these packages
# if you opt to use BSD licensing. The warranty disclaimer below holds
# in either instance.
#
# This complete copyright notice must be included in any revised version of the
# source code. Additional authorship citations may be added, but existing
# author citations must be preserved.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 2111-1307 USA
#

from EMAN2 import *
import os
import sys
import scipy
import time
import ntpath
import copy
import numpy as np
from scipy import sparse
from scipy import ndimage
import subprocess
import shutil


def get_usage():
	progname = os.path.basename(sys.argv[0])
	usage = progname + """ [options]
	e2tvrecon3d.py reconstructs a 3D tomogram from a tilt series and tlt tilt 
	angles file. In order to reconstruct the original image, we minimize a 
	function that is the sum of a L2 data fit term and the total variation of 
	the image. Proximal iterations using the Fast Iterative Shrinking & 
	Thresholding Algorithm (FISTA) are used.
	"""
	return usage


def print_usage():
	usage = get_usage()
	print "usage " + usage;
	print "Please run '" + progname + " -h' for detailed options"


def main():
	parser = EMArgumentParser(usage=get_usage())
	parser.add_argument("--tiltseries", default=None, help="The input projections. Project should usually have the xform.projection header attribute, which is used for slice insertion")
	parser.add_argument("--tlt", type=str, default=None, help="An imod tlt file containing alignment angles. If specified slices will be inserted using these angles in the IMOD convention")
	parser.add_argument("--output", default="threed.hdf", help="Output reconstructed tomogram file name.")
	parser.add_argument("--path",type=str,default='tvrecon_3d',help="Directory in which results will be stored.")
	parser.add_argument("--noclean",action="store_true",default=False, help="If specified, the program will not delete the excess files generated by this program.")
	parser.add_argument("--niters", default=10, type=int, help="Specify the number of iterative reconstructions to complete before returning the final reconstructed volume. The default number is 50")
	parser.add_argument("--beta", default=1.0, type=float, help="Specify the total-variation penalization/regularization weight parameter 'beta'. The default is 5.0.")
	parser.add_argument("--subpix", default=2, type=int, help="Specify the number of linear subdivisions used to compute the projection of one image pixel onto a detector pixel.")
	parser.add_argument("--verbose", "-v", dest="verbose", action="store", metavar="n", type=int, default=0, help="verbose level [0-9], higner number means higher level of verboseness")
	parser.add_argument("--parallel", action="store_true", default=False, help="Run all 2D reconstructions in parallel. This will become threaded parallel processing at some point.")
	parser.add_argument("--ppid", type=int, help="Set the PID of the parent process, used for cross platform PPID", default=-1)
	(options, args) = parser.parse_args()
	
	if options.tiltseries: 
		nslices = EMUtil.get_image_count( options.tiltseries )
	else: 
		print "You must specficy --tiltseries"
		exit(1)
		
	if options.tlt:
		tiltangles = np.asarray([ float( i ) for i in file( options.tlt , "r" ) ])
		tiltangles = tiltangles.tolist()
		nslices = len( tiltangles )
	else:
		print "You must specficy --tlt"
		exit(1)
	
	if options.niters: 
		niters = int(options.niters)
	
	beta = 1.0
	if options.beta: 
		beta = float(options.beta)
		if beta < 0:
			print "Parameter beta must be a positive, real number."
			exit(1)
	
	if options.subpix: 
		subpix = int(options.subpix)
	else: 
		subpix = 1
	
	if options.output: 
		outfilename = options.output
	else:
		outfilename = "threed.hdf"
	
	if options.parallel:
		options.parallel = True
	
	logger=E2init(sys.argv,options.ppid)
	if options.verbose > 1: print "e2tvrecon.py"
	
	# Create new output directory for this instance
	if options.verbose > 2: print "Generating instance directory..."
	options = makepath( options, options.path)
	rootpath = os.getcwd()
	options.path = rootpath + "/" + options.path
	
	if options.verbose > 2: print "Linking tilt series file to instance directory..."
	pathname = os.path.dirname(os.path.abspath( options.tiltseries ))
	filename = ntpath.basename( options.tiltseries )
	linkfrom = pathname + "/" + filename
	linkto = options.path + "/" + filename
	os.symlink( linkfrom, linkto )
	
	if options.verbose > 2: print "Linking tilt angles file to instance directory..."
	pathname = os.path.dirname(os.path.abspath( options.tlt ))
	filename = ntpath.basename( options.tlt )
	linkfrom = pathname + "/" + filename
	linkto = options.path + "/" + filename
	os.symlink( linkfrom, linkto )
	
	hdr = EMData( options.tiltseries, 0 , True)
	xsize = hdr['nx']
	ysize = hdr['ny']
	
	# Need to generate projection operator here. 
	# In the current scheme, it must be stored as a file,
	# but this may be an efficient storage technique 
	# since it's such a large data set.
	
	# Generate sinograms
	if options.verbose > 2: print "Generating %i tiltstacks..."%(ysize)
	sinograms = gen_sinograms(options, xsize, ysize)
	
	if options.verbose > 1:
		print "Performing 2D Reconstruction of All Generated Sinograms"
	
	os.chdir(options.path)
	i = 1
	for fname in os.listdir(options.path):
		if "sinogram" in fname:
			inputpath = fname
			twodpath = "twod.hdf"
			verbosity = str(options.verbose)
			tlt = options.tlt
			inputbeta = str(beta)
			if i >= 1000:
				reconpath = "slice_" + str(i)
			elif i >= 100:
				reconpath = "slice_0" + str(i)
			elif i >= 10:
				reconpath = "slice_00" + str(i)
			else:
				reconpath = "slice_000" + str(i)
			## PARALLELIZED
			if options.parallel:
				p = subprocess.Popen("e2tvrecon2d.py --tiltseries %s --tlt %s --path %s --output %s --beta %s -v %s --subpix %s"%(inputpath, tlt, reconpath, twodpath, inputbeta, verbosity, str(subpix)), shell=True)
			## UNPARALLELIZED
			else:
				p = subprocess.Popen("e2tvrecon2d.py --tiltseries %s --tlt %s --path %s --output %s --beta %s -v %s --subpix %s"%(inputpath, tlt, reconpath, twodpath, inputbeta, verbosity, str(subpix)), shell=True)
				p_status = p.wait()
			i += 1
	if options.parallel:
		p_status = p.wait()
	
	i = 1
	np_recons=[]
	for pname in os.listdir('.'):
		if "2Drecon_" in pname:
			for fname in os.listdir(pname):
				if twodpath in fname:
					recon = EMData( pname + "/" + fname, 0 )
					np_recon = recon.numpy().copy()
					np_recons.append(np_recon)
					i += 1
	reconstack = np.dstack( np_recons )
	from_numpy(reconstack).write_image( outfilename )
	
	if options.noclean != True:
		if options.verbose > 1: 
			print "Cleaning up current working directory..."
		for fname in os.listdir(options.path):
			if "sinogram_" in fname:
				os.remove( fname )
			if "recon_" in fname:
				shutil.rmtree( fname )
	
	E2end(logger)
	if options.verbose > 1: print "Exiting"
	return


# SINOGRAM GENERATION
def gen_sinograms( options, xlen, ylen ):
	"""
	Generates one 2D sinogram for each pixel along the y axis of a tiltseries.
	Returns a list whose enteies correspond to all of the sinograms generated.
	"""
	num_imgs = EMUtil.get_image_count( options.tiltseries )
	for y in range( ylen ):
		r = Region( 0, y, xlen, 1 )
		for imgnum in range( num_imgs ):
			prj = EMData( options.tiltseries, imgnum, False, r )
			if y >= 1000:
				prj.write_image(options.path + "/sinogram_"+str(y)+".hdf", imgnum)
			elif y >= 100:
				prj.write_image(options.path + "/sinogram_0"+str(y)+".hdf", imgnum)
			elif y >= 10:
				prj.write_image(options.path + "/sinogram_00"+str(y)+".hdf", imgnum)
			else:
				prj.write_image(options.path + "/sinogram_000"+str(y)+".hdf", imgnum)
		if options.verbose > 2:
			print "Generated sinogram %i of %i" %( y+1, ylen )
	return


def makepath(options, stem=''):
	if options.verbose > 5: print "makepath function called"
	if options.path and ("/" in options.path or "#" in options.path):
		print "Path specifier should be the name of a subdirectory to use in the current directory."
		print "Neither '/' or '#' can be included. Please edit your --path argument accordingly."
		sys.exit(1)
	if not options.path:
		options.path = stem + '_01'
		if options.verbose > 5:
			print "--path was not specified, therefore it will have the default value"
	files=os.listdir(os.getcwd())
	while options.path in files:
		if '_' not in options.path:
			options.path = options.path + '_00'
		else:
			#jobtag=''
			components=options.path.split('_')
			if components[-1].isdigit():
				components[-1] = str(int(components[-1])+1).zfill(2)
			else:
				components.append('00')
			options.path = '_'.join(components)
	if options.verbose > 5: print "The new options.path is", options.path
	if options.path not in files:
		if options.verbose > 5:
			print "Creating the following path: ", options.path
		os.system('mkdir ' + options.path)
	return options


if __name__=="__main__":
	main()

