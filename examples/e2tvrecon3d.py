#!/usr/bin/env python

#
# Author: James Michael Bell, 2014 (jmbell@bcm.edu)
# Copyright (c) 2014 Baylor College of Medicine
#
# For the original implementation of this FISTA TV algorithm, see:
# https://github.com/emmanuelle/tomo-tv.
#
# This software is issued under a joint BSD/GNU license. You may use the
# source code in this file under either license. However, note that the
# complete EMAN2 and SPARX software packages have some GPL dependencies,
# so you are responsible for compliance with the licenses of these packages
# if you opt to use BSD licensing. The warranty disclaimer below holds
# in either instance.
#
# This complete copyright notice must be included in any revised version of the
# source code. Additional authorship citations may be added, but existing
# author citations must be preserved.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 2111-1307 USA
#

from EMAN2 import *
import os
import sys
import scipy
import time
import ntpath
import copy
import numpy as np
import matplotlib.pyplot as plt
from scipy import sparse
from scipy import ndimage


def get_usage():
	progname = os.path.basename(sys.argv[0])
	usage = progname + """ [options]
	e2tvrecon3d.py reconstructs a 3D tomogram from a tilt series and tlt tilt 
	angles file. In order to reconstruct the original image, we minimize a 
	function that is the sum of a L2 data fit term and the total variation of 
	the image. Proximal iterations using the Fast Iterative Shrinking & 
	Thresholding Algorithm (FISTA) are used.
	"""
	return usage


def print_usage():
	usage = get_usage()
	print "usage " + usage;
	print "Please run '" + progname + " -h' for detailed options"


def main():
	parser = EMArgumentParser(usage=get_usage())
	parser.add_argument("--tiltseries", default=None, help="The input projections. Project should usually have the xform.projection header attribute, which is used for slice insertion")
	parser.add_argument("--tlt", type=str, default=None, help="An imod tlt file containing alignment angles. If specified slices will be inserted using these angles in the IMOD convention")
	parser.add_argument("--output", default="threed.hdf", help="Output reconstructed tomogram file name.")
	parser.add_argument("--path",type=str,default='tvrecon_3d',help="Directory in which results will be stored.")
	parser.add_argument("--noclean",action="store_true",default=False, help="If specified, the program will not delete the excess files generated by this program.")
	parser.add_argument("--niters", default=10, type=int, help="Specify the number of iterative reconstructions to complete before returning the final reconstructed volume. The default number is 50")
	parser.add_argument("--beta", default=5.0, type=float, help="Specify the total-variation penalization/regularization weight parameter 'beta'. The default is 5.0.")
	parser.add_argument("--subpix", default=1, type=int, help="Specify the number of linear subdivisions used to compute the projection of one image pixel onto a detector pixel.")
	parser.add_argument("--verbose", "-v", dest="verbose", action="store", metavar="n", type=int, default=0, help="verbose level [0-9], higner number means higher level of verboseness")
	parser.add_argument("--ppid", type=int, help="Set the PID of the parent process, used for cross platform PPID", default=-1)
	
	(options, args) = parser.parse_args()
	
	if options.tiltseries: 
		nslices = EMUtil.get_image_count( options.tiltseries )
	else: 
		print "You must speficy --tiltseries"
		exit(1)
		
	if options.tlt:
		tiltangles = np.asarray([ float( i ) for i in file( options.tlt , "r" ) ])
		tiltangles = tiltangles.tolist()
		nslices = len( tiltangles )
	else:
		print "You must speficy --tlt"
		exit(1)
	
	if options.niters: 
		niters = int(options.niters)
	
	beta = 5.0
	if options.beta: 
		beta = float(options.beta)
		if beta < 0:
			print "Parameter beta must be a positive, real number."
			exit(1)
	
	if options.subpix: 
		subpix = int(options.subpix)
	else: 
		subpix = 1
	
	if options.output: 
		outfilename = options.output
	else:
		outfilename = "3Drecon.hdf"
	
	logger=E2init(sys.argv,options.ppid)
	if options.verbose > 1: print "e2tvrecon.py"
	
	# Create new output directory for this instance
	if options.verbose > 2: print "Generating instance directory..."
	options = makepath( options, options.path)
	rootpath = os.getcwd()
	options.path = rootpath + "/" + options.path
	
	if options.verbose > 2: print "Linking tilt series file to instance directory..."
	pathname = os.path.dirname(os.path.abspath( options.tiltseries ))
	filename = ntpath.basename( options.tiltseries )
	linkfrom = pathname + "/" + filename
	linkto = options.path + "/" + filename
	os.symlink( linkfrom, linkto )
	
	if options.verbose > 2: print "Linking tilt angles file to instance directory..."
	pathname = os.path.dirname(os.path.abspath( options.tlt ))
	filename = ntpath.basename( options.tlt )
	linkfrom = pathname + "/" + filename
	linkto = options.path + "/" + filename
	os.symlink( linkfrom, linkto )
	
	## NEEDS OPTIMIZATION...
	xsize = EMData( options.tiltseries , 0 ).get_xsize()
	ysize = EMData( options.tiltseries , 0 ).get_ysize()
	
	# Generate sinograms
	if options.verbose > 2: print "Generating %i tiltstacks..."%(ysize)
	sinograms = gen_sinograms(options, xsize, ysize)
	
	if options.verbose > 1:
		print "Performing 2D Reconstruction of All Generated Sinograms"
	os.chdir(options.path)
	i = 1
	for fname in os.listdir(options.path):
		if "sinogram" in fname:
			if i < 10:
				reconpath = "sinogram_recon_0" + str(i)
			if i >= 10:
				reconpath = "sinogram_recon_" + str(i)
			inputpath = fname
			twodpath = "twod.hdf"
			tlt = options.tlt
			inputbeta = str(beta)
			os.popen("e2tvrecon2d.py --tiltseries %s --tlt %s --path %s --output %s --beta %s"%(inputpath, tlt, reconpath, twodpath, inputbeta))
			if options.verbose > 1:
				print "Sinogram Reconstruction %i complete"%(i)
			i += 1
	
	i = 0
	np_recons=[]
	for pname in os.listdir('.'):
		if "sinogram_recon" in pname:
			for fname in os.listdir(pname):
				if output in fname:
					recon = EMData(pname + "/" + fname, 0)
					np_recon = recon.numpy().copy()
					np_recons.append(np_recon)
					i += 1
	reconstack = np.dstack( np_recons )
	from_numpy(reconstack).write_image("threed_tv_recon.hdf")
	
	if options.noclean != True:
		if options.verbose > 1: 
			print "Cleaning up current working directory..."
		for pname in os.listdir(options.path):
			if "sinogram" in pname:
				os.remove( pname )
	
	E2end(logger)
	if options.verbose > 1: print "Exiting"
	return


# SINOGRAM GENERATION
# Here, a sinogram refers to a stacked collection of 1D projections. 
# Such a stack is generated for each y pixel.
def gen_sinograms( options, xlen, ylen ):
	"""
	Generates one 2D sinogram for each pixel along the y axis of a tiltseries.
	Returns a list whose enteies correspond to all of the sinograms generated.
	"""
	num_imgs = EMUtil.get_image_count( options.tiltseries )
	for y in range( ylen ):
		r = Region( 0, y, xlen, 1 )
		for imgnum in range( num_imgs ):
			prj = EMData( options.tiltseries, imgnum, False, r )
			if y < 10:
				prj.write_image(options.path + "/sinogram_0"+str(y)+".hdf", imgnum)
			if y >= 10:
				prj.write_image(options.path + "/sinogram_"+str(y)+".hdf", imgnum)
		if options.verbose > 2:
			print "Generated sinogram %i of %i" %( y+1, ylen )
	return


def makepath(options, stem=''):
	if options.verbose > 5: print "makepath function called"
	if options.path and ("/" in options.path or "#" in options.path):
		print "Path specifier should be the name of a subdirectory to use in the current directory."
		print "Neither '/' or '#' can be included. Please edit your --path argument accordingly."
		sys.exit(1)
	if not options.path:
		options.path = stem + '_01'
		if options.verbose > 5:
			print "--path was not specified, therefore it will have the default value"
	files=os.listdir(os.getcwd())
	while options.path in files:
		if '_' not in options.path:
			options.path = options.path + '_00'
		else:
			#jobtag=''
			components=options.path.split('_')
			if components[-1].isdigit():
				components[-1] = str(int(components[-1])+1).zfill(2)
			else:
				components.append('00')
			options.path = '_'.join(components)
	if options.verbose > 5: print "The new options.path is", options.path
	if options.path not in files:
		if options.verbose > 5:
			print "Creating the following path: ", options.path
		os.system('mkdir ' + options.path)
	return options


if __name__=="__main__":
	main()

