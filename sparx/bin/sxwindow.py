#!/usr/bin/env python
#
# Author: Shreekar Patel 03/28/2014 (Shreekar.Patel@uth.tmc.edu)
# Copyright (c) 2014 The University of Texas - Houston Medical School
#
# This software is issued under a joint BSD/GNU license. You may use the
# source code in this file under either license. However, note that the
# complete EMAN2 and SPARX software packages have some GPL dependencies,
# so you are responsible for compliance with the licenses of these packages
# if you opt to use BSD licensing. The warranty disclaimer below holds
# in either instance.
#
# This complete copyright notice must be included in any revised version of the
# source code. Additional authorship citations may be added, but existing
# author citations must be preserved.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
import os, sys
import json
from optparse import OptionParser

from EMAN2 import EMData, Region, Util
from utilities import read_text_row, set_ctf
from filter import filt_gaussh
from EMAN2jsondb import *

from global_def import *
from emboxerbase import *


def read_coordinates(mic_file):
	"""
	Read coordinates from .json files. Each micrograph outputs separate json file.
	Usually generated by executing:
		$ e2boxer.py --write_dbbox mic*.hdf --format=json
	"""
	coords = []
	data = json.loads(open(mic_file, 'r').read())
	print "\nDATA: ", mic_file
	for i in data.values():
# 		output[str(mic_name)] = coordinates
# 		print i
		for coord in i:
			pass
# 			print coord[0], coord[1]
			coords.append([coord[0], coord[1]])
	print "DATA END\n"
	return coords


def window(mic_files):
	"""
	Using coordinates window particles, and add ctf information to it.
	"""
	for k, info in data.items():
		print 'Processing {0}'.format(k)
		box_size = data[k]['box_size']
		pixel_ratio = float(data[k]['input_pixel'])/float(data[k]['output_pixel'])
		img = EMData()
		img.read_image(k)
		img_filt = filt_gaussh(img, pixel_ratio/box_size)


		if pixel_ratio != 1.0:
			print "Generating downsampled image\n"
			sb = Util.sincBlackman(15, .5 * pixel_ratio,1999) # 1999 taken directly from util_sparx.h
			img_filt = img_filt.downsample(sb, pixel_ratio)
			box_size = box_size / pixel_ratio

		output_file_name = 'out_' + os.path.basename(k)
		clip = EMData()
		for i, (x, y) in enumerate(data[k]['coordinates']):
			reg = Region((x * pixel_ratio)-box_size//2, (y * pixel_ratio)-box_size//2, box_size, box_size)
			clip = img_filt.get_clip(reg)
			clip.write_image(output_file_name, i)
		# Set ctf
		set_ctf(clip, data[k]['ctf'])
		print 'Windowed prticles for {0} -> {1}'.format(k, output_file_name)

def main():
	progname = os.path.basename(sys.argv[0])
	usage = progname + " -c,--coord=coord  -f,--ctf=ctf_file  -m,--mic_dir=mic_dir  -i,--input_pixel=input_pixel  -o,--output_pixel=output_pixel"
	
	parser = OptionParser(usage, version=SPARXVERSION)

	parser.add_option('-c', '--coord', dest='coord', help='location where coordinates are located')
	parser.add_option('-f', '--ctf', dest='ctf_file', help='ctf information file')
	parser.add_option('-m', '--mic_dir', dest='mic_dir', help='micrograph location')
	parser.add_option('-i', '--input_pixel', dest='input_pixel', help='input pixel size', default=1)
	parser.add_option('-o', '--output_pixel', dest='output_pixel', help='output pixel size', default=1)
		
	(options, args) = parser.parse_args()	
	
	if len(args) > 1: # or len(args) > 6:
		print "\nusage: " + usage
		print "Please run '" + progname + " -h' for detailed options\n"
	else:
		im = EMData('mic0.hdf')
		ff= os.path.join(options.coord,'mic0_info.json')
		js = js_open_dict(ff)["boxes"]
		for i in range(len(js)):
			x = js[i][0]
			y = js[i][1]
# 			print i,x, y
			imn=Util.window(im,int(x),int(y))
# # 			Image stack
			imn.write_image('mic0_ppp.hdf', -1) #appending to the image stack
		exit
		
		dbs={}
		for f in os.listdir(options.coord):
					if f.endswith('.json') and f.startswith('mic'):						
						fName =  os.path.join(options.coord,f)
						dbs[fName] = js_open_dict(fName)["boxes"]


# 		print dbs
		for d in dbs:
			print d
# 			# micname is full path name
# 	# smic[-1] is micrograph name minus path
# 	smic = micname.split('/')
# 	# filename is name of micrograph minus the path and extension
# 	filename = (smic[-1].split('.'))[0]

# 			im = EMData('mic0.hdf')
# 			for i in range(len(dbs[d])):
# 				x = dbs[d][i][0]
# 				y = dbs[d][i][1]
# # 				print i,x, y
# 				imn=Util.window(im,int(x),int(y))
# 				imn.write_image('mic0_ppp.hdf', -1) #appending to the image stack


if __name__=='__main__':
	main()
