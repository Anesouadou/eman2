#!/usr/bin/env python
#
# Author: David Woolford 11/10/08 (woolford@bcm.edu)
# Copyright (c) 2000-2008 Baylor College of Medicine
#
# This software is issued under a joint BSD/GNU license. You may use the
# source code in this file under either license. However, note that the
# complete EMAN2 and SPARX software packages have some GPL dependencies,
# so you are responsible for compliance with the licenses of these packages
# if you opt to use BSD licensing. The warranty disclaimer below holds
# in either instance.
#
# This complete copyright notice must be included in any revised version of the
# source code. Additional authorship citations may be added, but existing
# author citations must be preserved.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston MA 02111-1307 USA
#
#


from emsprworkflow import *
from emform import *
from emsave import EMFileTypeValidator
from emapplication import error, EMErrorMessageDisplay

class EMProjectListCleanup:
	'''
	'''
	def clean_up_ali_params(dict_db_name="global.tpr_ptcls_ali_dict"):
		project_db = db_open_dict("bdb:project")
		db_map = project_db.get(dict_db_name,dfl={})
		
		error = []
		update = False
		for name,map in db_map.items():
			if not file_exists(name):
				db_map.pop(name)
				error.append("%s data no longer exists. Automatically removing from project alignment parameters" %(name))
				update = True
				continue
			for image_name,ali in map.items():
				if not file_exists(image_name):
					map.pop(image_name)
					error.append("%s data no longer exists for %s. Automatically removing from project alignment parameters" %(image_name,name))
					update = True
			if len(map) == 0:
				db_map.pop(name)
					
		if update:
			EMErrorMessageDisplay.run(error,"Warning")
			project_db[dict_db_name] = db_map			
	
	clean_up_ali_params = staticmethod(clean_up_ali_params)


class EMTomoRawDataReportTask(EMRawDataReportTask):
	'''The tools under this tab are highly experimental. ''' 
	def __init__(self):
		EMRawDataReportTask.__init__(self)
		self.project_list = tpr_raw_data_dict
		
	def get_raw_data_table(self):
		'''
		Gets an EMTomographicFileTable - this is type of class that the emform knows how to handle 
		'''
		data_dict = EMProjectDataDict(self.project_list)
		project_data = data_dict.get_data_dict()
		project_names = project_data.keys()
		self.project_data_at_init = project_data # so if the user hits cancel this can be reset

		from emform import EMTomographicFileTable,EMFileTable
		table = EMTomographicFileTable(project_names,desc_short="Tomograms",desc_long="")
		context_menu_data = EMRawDataReportTask.ProjectListContextMenu(self.project_list)
		table.add_context_menu_data(context_menu_data)
		table.add_button_data(EMRawDataReportTask.ProjectAddRawDataButton(table,context_menu_data))
	
		#p.append(pdims) # don't think this is really necessary
		return table,len(project_names)

class EMReconstructAliFile(WorkFlowTask):
	'''Use this task for reconstructing IMOD ali into 3D volumes using EMAN2's Fourier reconstructor. This requires you to supply the tlt file and ali files that are generated by IMOD.'''

	def __init__(self):
		WorkFlowTask.__init__(self)
		self.window_title = "Reconstruct ALI File"
		self.preferred_size = (640,480)
		self.form_db_name = "bdb:emform.reconstruct_ali"
	
	def get_params(self):
		params = []
		db = db_open_dict(self.form_db_name)
		
		plot_table = EMPlotTable(name="tltfile",desc_short="TLT file",desc_long="Use this tool to browse for your tlt file",single_selection=True)
		ali_table = EMTomographicFileTable(name="alifile",desc_short="ALI file",desc_long="Use this tool to browse for your ali file",single_selection=True)
		
		
		context_menu_data = ParticleWorkFlowTask.DataContextMenu(EMFileTypeValidator("ali"))
		ali_table.add_context_menu_data(context_menu_data)
		ali_table.add_button_data(ParticleWorkFlowTask.AddDataButton(ali_table,context_menu_data))
		
		context_menu_data2 = ParticleWorkFlowTask.DataContextMenu(EMFileTypeValidator("tlt"))
		plot_table.add_context_menu_data(context_menu_data2)
		plot_table.add_button_data(ParticleWorkFlowTask.AddDataButton(plot_table,context_menu_data2))

		ali_table.add_column_data(EMFileTable.EMColumnData("Image Dims",EMParticleReportTask.get_particle_dims,"The dimensions of the image on disk"))
		plot_table.add_column_data(EMFileTable.EMColumnData("Rows",EMPlotTable.num_plot_entries,"The number of lines in the file"))
		
#		clip = ParamDef(name="clip",vartype="int",desc_short="Clip ALI images to",desc_long="clipping which is applied after scale ",property=None,defaultunits=db.get("clip",dfl=""),choices=None)
		scale = ParamDef(name="scale",vartype="float",desc_short="Scale ALI pixel width",desc_long="Scales the input image pixel spacing by the given amount",property=None,defaultunits=db.get("scale",dfl=1.0),choices=None)
		pad = ParamDef(name="pad",vartype="int",desc_short="Zero Padding",desc_long="Padding applied after the images have been scaled and clipped",property=None,defaultunits=db.get("pad",dfl=""),choices=None)
		
		zsample = ParamDef(name="zsample",vartype="int",desc_short="Z sampling of reconstructed volume",desc_long="The size of the z dimension of the reconstructed volume",property=None,defaultunits=db.get("zsample",dfl=0),choices=None)
		
		params.append(ParamDef(name="blurb",vartype="text",desc_short="Reconstructing and ALI file",desc_long="",property=None,defaultunits=self.__doc__,choices=None))
		params.append([ali_table,plot_table])
		params.append(scale)
		params.append(pad)
		params.append(zsample)
		return params

	def check_params(self,params):
		error_msg = []
		for sample in ["zsample"]:
			if not params.has_key(sample) or params[sample] <= 0:
				error_msg.append("%s must be greater than zero" %sample)
		
		tltok = True
		if not params.has_key("tltfile") or len(params["tltfile"]) != 1:
			error_msg.append("You have to supply a single TLT file")
			tltok = False
		else:
			try:
				f = file(params["tltfile"][0],"r")
				lines = f.readlines()
				n_lines = len(lines)
			except:
				error_msg.append("The TLT file is not recognized")
				tltok = False
		
		aliok = True
		if not params.has_key("alifile") or len(params["alifile"]) != 1:
			error_msg.append("You have to supply a single ALI file")
			aliok = False
		else:
			try:
				nx,ny,nz = gimme_image_dimensions3D(params["alifile"][0])
			except:
				error_msg.append("The ALI file is not recognized")
				aliok = False
			
		if aliok and tltok:
			if nz != n_lines:
				error_msg.append("The z dimension of the ALI file (%d) has to match the number of lines in the TLT file (%d)" %(nz,n_lines))
				
		if aliok:
			scale_ok = True
			if params.has_key("scale"):
				if params["scale"] <= 0:
					error_msg.append("scale must be greater than zero")
					scale_ok = False
			else:
				params["scale"] = 1.0
				scale_ok = False
				
			params["clip"] = params["scale"]*nx
				
				
			if params.has_key("pad"):
				if params["pad"] <= 0:
					error_msg.append("pad must be greater than zero")
				else:
					if params["pad"] <= params["clip"]:
						 error_msg.append("pad (%d) must be great than the size of the scaled images (%d)" %(params["pad"],params["clip"]))		 
	
	
		return error_msg
	
	def get_output_name(self):
		tag = "bdb:tomograms#tomogram_"
		
		if not os.path.isdir("tomograms"):
			os.makedirs("tomograms") 
		
		idx = 0
		while 1:
			sidx = str(idx)
			if len(sidx) == 1:
				sidx = "0" + sidx
				
			name = tag + sidx
			if not db_check_dict(name): 
				print name,"does not exists as a db"
				break
			idx +=1
			
		return name
	
	def on_form_ok(self,params):
		
		error_message = self.check_params(params)
		if len(error_message):
			self.show_error_message(error_message)
			return
		
		options = EmptyObject()
		options.input = params["alifile"][0]
		options.tlt = params["tltfile"][0]
		options.dbls = tpr_raw_data_dict
		options.output = self.get_output_name()
		options.recon = "fourier:zsample=%s" %(params["zsample"])
		options.iter = "0"
		options.sym = "c1"
		
		
		
		string_args = ["input","tlt","recon","iter","sym","output","dbls"]
		bool_args = []
		additional_args = ["--lowmem","--preprocess=normalize.edgemean"]
		temp_file_name = "e2make3d_stdout.txt"
		
		if params.has_key("pad"):
			options.pad = params["pad"]
			string_args.append("pad")
			
		nx,ny,nz = gimme_image_dimensions3D(params["alifile"][0])
		if params["scale"] != 1.0 or params["clip"] != nx:
			options.preprocess = "xform.scale:scale=%s:clip=%s" %(params["scale"],params["clip"])
			string_args.append("preprocess")
		self.spawn_single_task('e2make3d.py',options,string_args,bool_args,additional_args,temp_file_name)
		
		
		self.write_db_entries(params)
		self.emit(QtCore.SIGNAL("task_idle"))
		self.form.close()
		self.form = None

class EMTomoPtclReportTool:
	''' has a, not is a'''
	def __init__(self,project_dict=tpr_ptcls_dict,title="Set Me Please",name="filenames"):
		self.project_dict = project_dict
		self.project_data_at_init = None
		self.title = title
		self.name= name
		
	def get_particle_table(self):
		data_dict = EMProjectDataDict(self.project_dict)
		ptcls_data = data_dict.get_data_dict()
		ptcls_list = ptcls_data.keys()
		self.project_data_at_init = ptcls_data # so if the user hits cancel this can be reset

		table =  self.get_particle_table_with_ptcls(ptcls_list)
		context_menu_data = EMRawDataReportTask.ProjectListContextMenu(self.project_dict)
		table.add_context_menu_data(context_menu_data)
		table.add_button_data(EMRawDataReportTask.ProjectAddRawDataButton(table,context_menu_data))
		return table
	
	def get_particle_table_with_ptcls(self,ptcls_list):
		
		from emform import EM3DFileTable,EMFileTable
		table = EM3DFileTable(ptcls_list,name=self.name,desc_short=self.title,desc_long="")
		table.insert_column_data(1,EMFileTable.EMColumnData("Particle Dims",EMParticleReportTask.get_particle_dims,"The dimensions of the particles that are stored on disk"))
		return table
	
class EMTomoParticleReportTask(WorkFlowTask):
	"""This form shows the boxed tomographic particles that are associated with the project. You can optionally add your own particles."""
	def __init__(self,project_dict=tpr_ptcls_dict):
		WorkFlowTask.__init__(self)
		self.window_title = "Project Tomo Particles"
		self.project_dict = project_dict
		self.table_tool = None

	def get_params(self):
		params = []
		
		self.table_tool = EMTomoPtclReportTool(self.project_dict,self.window_title)
		table = self.table_tool.get_particle_table()
		
		params.append(ParamDef(name="blurb",vartype="text",desc_short="",desc_long="",property=None,defaultunits=self.__doc__,choices=None))
		params.append(table)  
		
		return params

class EMTomoProbeReportTask(EMTomoParticleReportTask):
	"""This form shows the boxed tomographic probes that are associated with the project. Currently the only way to add probes is to browse and add them manually."""
	def __init__(self):
		EMTomoParticleReportTask.__init__(self,tpr_probes_dict)
		self.window_title = "Project Tomo Probes"
		
class EMTomoAveragesReportTask(EMTomoParticleReportTask):
	"""This form shows the results of any tomographic particle averaging you have performed."""
	def __init__(self):
		EMTomoParticleReportTask.__init__(self,tpr_ptcl_ave_dict)
		self.window_title = "Project Tomogram Averages"
		
class EMTomoGenericReportTask(WorkFlowTask):
	"""This form shows the images that you selected"""
	def __init__(self,ptcls_list=[]):
		WorkFlowTask.__init__(self)
		self.window_title = "Tomo Particles"
		self.table_tool = None
		self.ptcls_list = ptcls_list
	def get_params(self):
		params = []
		
		self.table_tool = EMTomoPtclReportTool()
		table = self.table_tool.get_particle_table_with_ptcls(self.ptcls_list)
		
		params.append(ParamDef(name="blurb",vartype="text",desc_short="",desc_long="",property=None,defaultunits=self.__doc__,choices=None))
		params.append(table)  
		
		return params
	
class EMBaseTomoChooseFilteredPtclsTask(WorkFlowTask):
	"""Choose the data""" 
	def __init__(self):
		WorkFlowTask.__init__(self)
		self.window_title = "Choose Filtered Images To Display"
		self.preferred_size = (480,300)
		
	def get_params(self):
		ptcl_opts = EMPartSetOptions(tpr_ptcls_dict)
		self.particles_map, self.particles_name_map, choices, self.name_map = ptcl_opts.get_particle_options()
		
		#if as_string:
		#params.append(ParamDef(name="particle_set_choice",vartype="string",desc_long="Choose the particle data set you wish to use to generate a starting data for e2refine2d",desc_short=title,property=None,defaultunits=db.get("particle_set_choice",dfl=""),choices=choices))
		db = db_open_dict(self.form_db_name)
		params = []
		params.append(ParamDef(name="blurb",vartype="text",desc_short="",desc_long="",property=None,defaultunits=self.__doc__,choices=None))
		if len(choices) > 0:
			if len(choices) == 1:
				vartype = "choice"
			else:
				vartype = "string"
				
			params.append(ParamDef(name="tomo_filt_choice",vartype=vartype,desc_long="Choose from the filtered tomogram particles",desc_short="Choose data",property=None,defaultunits=db.get("tomo_filt_choice",dfl=""),choices=choices))				
		else:
			params.append(ParamDef(name="blurb2",vartype="text",desc_short="",desc_long="",property=None,defaultunits="There are no particles in the project. Go back to earlier stages and box/import particles",choices=None))
		return params

	def on_form_ok(self,params):
		raise NotImplementedException("Inheriting classes must implement this function")

class EMTomoChooseAlignedSetTask(EMBaseTomoChooseFilteredPtclsTask):
	"""Choose the particle set for which you wish to investigate the alignment results. The available sets inlcude the raw particles, and any filtered sets you have previously generated.""" 
	def __init__(self):
		EMBaseTomoChooseFilteredPtclsTask.__init__(self)
		self.form_db_name ="bdb:tomo.choose.filtered.ali"

	def on_form_ok(self,params):
		if not params.has_key("tomo_filt_choice") or params["tomo_filt_choice"] == None:
			error("Please choose some data")
			return
		choice = params["tomo_filt_choice"]
#				
		task = EMTomoPtclAlignmentReportTask(self.particles_map[self.particles_name_map[choice]])
		self.emit(QtCore.SIGNAL("replace_task"),task,"Alignment Parameters")
		self.form.close()
		self.form = None
		self.write_db_entries(params)

class EMTomoPtclAlignmentReportTask(WorkFlowTask):
	"""This form shows the results of any alignments you have performed. It also lists the most likely alignment for each probe."""
	def __init__(self,ptcls_list=[]):
		WorkFlowTask.__init__(self)
		self.window_title = "Alignment Report"
		self.ptcls_list = ptcls_list
	def get_params(self):
		params = []
		
		self.table_tool = EMTomoPtclReportTool(title="Tomogram Particles")
		table = self.table_tool.get_particle_table_with_ptcls(self.ptcls_list)
		
		columns = self.get_column_names()
		for c in columns:
			d = EMTomoPtclAlignmentReportTask.AlignmentColumn(c)
			table.insert_column_data(0,EMFileTable.EMColumnData(get_file_tag(c),d.get_ali_params,"Alignment parameters"))
		
		params.append(ParamDef(name="blurb",vartype="text",desc_short="",desc_long="",property=None,defaultunits=self.__doc__,choices=None))
		params.append(table)  
		
		return params
	
	def get_column_names(self):
		
		project_list = tpr_ptcls_ali_dict
		db = db_open_dict("bdb:project",ro=True)
		db_map = db.get(project_list,dfl={})
		
		columns = []
		for key,dct in db_map.items():
			for probe,alis in dct.items():
				if probe not in columns:
					columns.append(probe)
					
		return columns
	
	class AlignmentColumn:
		'''
		Basically some functions with a cache - the cache is to avoid
		re-reading stuff from disk multiple times
		'''
		def __init__(self,probe,ali_set=None):
			self.project_list = tpr_ptcls_ali_dict
			db = db_open_dict("bdb:project",ro=True)
			self.db_map = db[self.project_list]
			self.probe = probe
			self.ali_set = ali_set
			if self.ali_set != None:
				ptcl_opts = EMPartSetOptions(tpr_ptcls_dict)
				self.particles_map, self.particles_name_map, choices, self.name_map = ptcl_opts.get_particle_options()
				tls = EMProbeAliTools()
				self.probe_set_map,self.probe_and_ali,self.probe_name_map = tls.accrue_data()
				self.base_set = self.probe_set_map[get_file_tag(self.probe)][self.ali_set]
				self.ptcl_base_set = [self.name_map[name] for name in self.base_set]
				
		def get_ali_params(self,name):
			if self.db_map == None: return "-"
			
			if self.ali_set != None:
				base_name = self.name_map[name]
			
				
				for i in xrange(0,len(self.base_set)):
					if base_name == self.ptcl_base_set[i]:
						dct = self.db_map[self.base_set[i]]
						if dct.has_key(self.probe):
							alis = dct[self.probe]
							t = alis[0]
							params = t.get_params("eman")
							s = "Az,Alt,Phi:[%.1f,%.1f,%.1f], X,Y,Z:[%.1f,%.1f,%.1f]" %(params["az"],params["alt"],params["phi"],params["tx"],params["ty"],params["tz"])
							return s
						
				return "-"
				
			if self.db_map.has_key(name):
				dct = self.db_map[name]
				if dct.has_key(self.probe):
					alis = dct[self.probe]
					t = alis[0]
					params = t.get_params("eman")
					s = "Az,Alt,Phi:[%.1f,%.1f,%.1f], X,Y,Z:[%.1f,%.1f,%.1f]" %(params["az"],params["alt"],params["phi"],params["tx"],params["ty"],params["tz"])
					return s
				
			return "-"
				
class E2TomoBoxerGuiTask(WorkFlowTask):
	"""Select the file you want to process and hit okay, this will launch e2tomoboxer. If it's the first time you're launching e2tomoboxer with the given data you will have to wait a few minutes for automatic shrinking and projection to occur."""
	
	def __init__(self):
		WorkFlowTask.__init__(self)
		self.tomo_boxer_module = None
		self.window_title = "Launch e2tomoboxer"
		self.report_task = None
		
	def get_tomo_boxer_basic_table(self):
		'''
		'''
		
		self.report_task = EMTomoRawDataReportTask()
		table,n = self.report_task.get_raw_data_table()# now p is a EMParamTable with rows for as many files as there in the project
		from emform import EMFileTable,int_lt
		table.insert_column_data(0,EMFileTable.EMColumnData("Stored Boxes",E2TomoBoxerGuiTask.get_tomo_boxes_in_database,"Boxes currently stored in the EMAN2 database",int_lt))
		
		return table, n

	def get_tomo_boxes_in_database(name):
		print "checking for boxes, but this aspect of things is not working yet...."+get_file_tag(name)+" "+name
		#from e2tomoboxer import tomo_db_name
		#if db_check_dict(tomo_db_name):
			#tomo_db = db_open_dict(tomo_db_name)
			#image_dict = tomo_db.get(get_file_tag(name),dfl={})
			#if image_dict.has_key("coords"):
				#return str(len(image_dict["coords"]))
		
		return "0"
	
	get_tomo_boxes_in_database = staticmethod(get_tomo_boxes_in_database)
	
	def get_params(self):
		params = []
		
		p,n = self.get_tomo_boxer_basic_table() # note n is unused, it's a refactoring residual		
		params.append(ParamDef(name="blurb",vartype="text",desc_short="Interactive use of e2tomoboxer",desc_long="",property=None,defaultunits=self.__doc__,choices=None))
		params.append(p)
		pylong = ParamDef(name="yshort",vartype="boolean",desc_short="yshort",desc_long="Use Z axis as normal",property=None,defaultunits=1,choices=None)
		pinmem = ParamDef(name="inmemory",vartype="boolean",desc_short="inmemory",desc_long="Load the tomo into memory",property=None,defaultunits=1,choices=None)
		papix = ParamDef(name="apix",vartype="float",desc_short="Angstroms per pixel", desc_long="Angstroms per pixel",property=None,defaultunits=1.0,choices=None )
		params.append([pylong, pinmem])
		params.append(papix)
#		db = db_open_dict(self.form_db_name)
#		params.append(ParamDef(name="interface_boxsize",vartype="int",desc_short="Box size",desc_long="An integer value",property=None,defaultunits=db.get("interface_boxsize",dfl=128),choices=[]))
#		#db_close_dict(self.form_db_name)
		return params
	
	def on_form_ok(self,params):
		
		if not params.has_key("filenames"):
			EMErrorMessageDisplay.run(["Please select files for processing"])
			return
		
		if  params.has_key("filenames") and len(params["filenames"]) == 0:
			EMErrorMessageDisplay.run(["Please select files for processing"])
			return

		self.write_db_entries(params)

		e2tblist = []
		e2tblist.append("e2tomoboxer.py")
		e2tblist.append(params['filenames'][0])
		if params["yshort"]:
			e2tblist.append("--yshort")
		if params["inmemory"]:
			e2tblist.append("--inmemory")
		e2tblist.append("--apix="+str(params["apix"]))
		print e2tblist
		
		child = subprocess.Popen(e2tblist)
		
		self.form.close()
		self.form = None
		
	def on_form_close(self):
		# this is to avoid a task_idle signal, which would be incorrect if e2boxer is running
		if self.tomo_boxer_module == None:
			self.emit(QtCore.SIGNAL("task_idle"))
		else: pass
	
	def on_boxer_closed(self): 
		if self.tomo_boxer_module != None:
			self.tomo_boxer_module = None
			self.emit(QtCore.SIGNAL("gui_exit"))
	
	def on_boxer_idle(self):
		'''
		Presently this means boxer did stuff but never opened any guis, so it's safe just to emit the signal
		'''
		self.tomo_boxer_module = None
		self.emit(QtCore.SIGNAL("gui_exit"))
		
	def on_form_cancel(self):
		if self.report_task:
			self.report_task.recover_original_raw_data_list()
		
		self.form.close()
		self.form = None
		self.emit(QtCore.SIGNAL("task_idle"))
	

class EMTomoStoredCoordsTool:
	'''This class represents a step towards 'has a' as opposed to 'is a' relationships'''
	def __init__(self):
		self.project_list = tpr_raw_data_dict
		self.project_data_at_init  = None
	
	def get_raw_data_table(self):
		data_dict = EMProjectDataDict(self.project_list)
		project_data = data_dict.get_data_dict()
		project_names = project_data.keys()
		self.project_data_at_init = project_data # so if the user hits cancel this can be reset

		from emform import EM2DFileTable,EMFileTable
		table = EM2DFileTable(project_names,desc_short="Tomograms",desc_long="")
		context_menu_data = EMRawDataReportTask.ProjectListContextMenu(self.project_list)
		table.add_context_menu_data(context_menu_data)
		table.add_button_data(EMRawDataReportTask.ProjectAddRawDataButton(table,context_menu_data))
		return table
	def get_files_with_db_boxes_table(self):
		data_dict = EMProjectDataDict(self.project_list)
		project_data = data_dict.get_data_dict() # this is for automated clean up only...
		
		table= self.get_raw_data_table()# now p is a EMParamTable with rows for as many files as there in the project
		from emform import EMFileTable,int_lt
	
		table.insert_column_data(0,EMFileTable.EMColumnData("Stored Boxes",E2TomoBoxerGuiTask.get_tomo_boxes_in_database,"Boxes currently stored in the EMAN2 database",int_lt))
		self.columns_object = E2BoxerTask.ParticleColumns(tpr_ptcls_dict)
		table.insert_column_data(1,EMFileTable.EMColumnData("Particle Dims",self.columns_object.get_particle_dims_project,"The dimensions of the particles that are stored on disk"))
		#self.tmp = E2BoxerTask.Tmp()
		return table
	
	def recover_original_raw_data_list(self):
		'''
		Called if the user hits cancel - if they removed some files or added files the changes
		are not saved unless the user hits ok
		'''
		project_db = db_open_dict("bdb:project")
		project_db[self.project_list] = self.project_data_at_init

class E2TomoBoxerOutputTask(WorkFlowTask):	
	"""Select the images you wish to generate output for, enter the box size and normalization etc, and then hit OK.\nThis will cause the workflow to spawn output writing processes using the available CPUs. Note that the bdb option is the preferred output format, in this mode output particles are written directly to the EMAN project database. Once the output writing tasks are done check 'Tomogram Particles' form, which will be automatically updated."""
	def __init__(self):
		WorkFlowTask.__init__(self)
		self.window_title = "Generate e2tomoboxer Output"
		self.output_formats = ["bdb","hdf"] # disable img from the workflow because in EMAN2 we want to store more metadata in the header
		self.form_db_name = "bdb:emform.e2tomoboxer.output"
		self.tools = None
#	def __del__(self):
#		print "output task dies"
	
	def get_params(self):
		params = []
		
		self.tools = EMTomoStoredCoordsTool()
		
		
		p = self.tools.get_files_with_db_boxes_table()
		params.append(ParamDef(name="blurb",vartype="text",desc_short="Using e2boxer",desc_long="",property=None,defaultunits=self.__doc__,choices=None))
		params.append(p)
		self.add_general_params(params)

		return params
	
	def add_general_params(self,params):
		'''
		Functionality used in several places
		'''
		db = db_open_dict(self.form_db_name)
		pbox = ParamDef(name="output_boxsize",vartype="int",desc_short="Box size",desc_long="An integer value",property=None,defaultunits=db.get("output_boxsize",dfl=128),choices=[])	
		pfo = ParamDef(name="force",vartype="boolean",desc_short="Force overwrite",desc_long="Whether or not to force overwrite files that already exist",property=None,defaultunits=db.get("force",dfl=False),choices=None)
		pinv = ParamDef(name="invertoutput",vartype="boolean",desc_short="Invert",desc_long="Do you want the pixel intensities in the output inverted?",property=None,defaultunits=db.get("invertoutput",dfl=False),choices=None)
		pn =  ParamDef(name="normproc",vartype="string",desc_short="Normalize images",desc_long="How the output box images should be normalized",property=None,defaultunits=db.get("normproc",dfl="normalize.edgemean"),choices=["normalize","normalize.edgemean","None"])
		pop = ParamDef(name="outformat",vartype="string",desc_short="Output image format",desc_long="The format of the output box images",property=None,defaultunits=db.get("outformat",dfl="bdb"),choices=self.output_formats)
				
		params.append([pbox,pfo,pinv])
		params.append(pn)
		params.append(pop)
		
	
	def check_params(self,params):
		
		error_message = []
		if params["output_boxsize"] < 1: error_message.append("Boxsize must be greater than 0.")
		
		return error_message
	
	def on_form_ok(self,params):	
		if  params.has_key("filenames") and len(params["filenames"]) == 0:
			self.run_select_files_msg()
			return
		
		error_message = self.check_params(params)
		if len(error_message) >0: 
			self.show_error_message(error_message)
			return
		
		else:
			self.write_db_entries(params)
			options = EmptyObject()
			for k,v in params.items():
				setattr(options,k,v)	
			options.boxsize = params["output_boxsize"]
			
			options.writeoutput=True # this is implicit, it has to happen
			
			string_args = ["normproc","outformat","boxsize"]
			bool_args = ["force","writeoutput","invertoutput"]
			additional_args = ["--dbls=%s" %tpr_ptcls_dict]
			temp_file_name = "e2tomoboxer_output_stdout.txt"
			self.spawn_task("e2tomoboxer.py",options,string_args,bool_args,additional_args,temp_file_name)
			self.emit(QtCore.SIGNAL("task_idle"))
			self.form.close()
			self.form = None

	def on_form_cancel(self):
		if self.tools:
			self.tools.recover_original_raw_data_list()
		
		self.form.close()
		self.form = None
		self.emit(QtCore.SIGNAL("task_idle"))

class EMTomoChooseFilteredPtclsTask(EMBaseTomoChooseFilteredPtclsTask):
	"""Choose the particle set you wish to filter. The available sets inlcude the raw particles, and any filtered sets you have previously generated.""" 
	def __init__(self):
		EMBaseTomoChooseFilteredPtclsTask.__init__(self)
		self.form_db_name ="bdb:tomo.choose.filtered"

	def on_form_ok(self,params):
		if not params.has_key("tomo_filt_choice") or params["tomo_filt_choice"] == None:
			error("Please choose some data")
			return
		choice = params["tomo_filt_choice"]
		
		task = EMTomoGenericReportTask(self.particles_map[self.particles_name_map[choice]])
		self.emit(QtCore.SIGNAL("replace_task"),task,"Filter Tomo Particles")
		self.form.close()
		self.form = None
		
		self.write_db_entries(params)



class E2TomoFilterParticlesTask(WorkFlowTask):	
	"""This task is for Fourier filtering and/or rotating your data. If you choose to perform both of these operations, the Fourier filtering is performed before the rotation."""
	
	preprocessor_cache = None
	def __init__(self,ptcls_list=[],name_map={}):
		WorkFlowTask.__init__(self)
		self.window_title = "Filter Tomogram Particles"
		self.output_formats = ["bdb","hdf"] # disable img from the workflow because in EMAN2 we want to store more metadata in the header
		self.form_db_name = "bdb:emform.tomo.filter_particles"
		self.project_dict = tpr_ptcls_dict
		self.ptcls_list = ptcls_list
		self.name_map = name_map
		
	def get_params(self):
		params = []
		
		params = []
		
		self.table_tool = EMTomoPtclReportTool(self.project_dict,self.window_title)
		table = self.table_tool.get_particle_table_with_ptcls(self.ptcls_list)
		
		params.append(ParamDef(name="blurb",vartype="text",desc_short="",desc_long="",property=None,defaultunits=self.__doc__,choices=None))
		params.append(table)
		self.add_filt_params(params)
		db = db_open_dict(self.form_db_name)
		pname =  ParamDef("name",vartype="string",desc_short="Filtered set name",desc_long="The processed sets will be referred to by this name",property=None,defaultunits=db.get("name",dfl="filt"),choices=[])
		params.append(pname)
		return params
	
	def add_filt_params(self,params):
		'''
		'''
		db = db_open_dict(self.form_db_name)
		az = ParamDef(name="az",vartype="float",desc_short="Az rotation",desc_long="Rotate your model about the z axis",property=None,defaultunits=db.get("az",0.0),choices=None)
		alt = ParamDef(name="alt",vartype="float",desc_short="Alt rotation",desc_long="Rotate your model about the x axis",property=None,defaultunits=db.get("alt",0.0),choices=None)
		phi = ParamDef(name="phi",vartype="float",desc_short="Phi rotation",desc_long="Rotate your model about the z' axis",property=None,defaultunits=db.get("phi",0.0),choices=None)
		ppostproc =  ParamDef("filter",vartype="string",desc_short="Filter",desc_long="A post processor applied to the reconstructed model",property=None,defaultunits=db.get("filter",dfl="None"),choices=self.get_postprocess_filt_options())
		ppostprocargs =  ParamDef(name="filterargs",vartype="string",desc_short="params",desc_long="Parameters for the post processor see \"e2help.py processors\"",property=None,defaultunits=db.get("filterargs",dfl=""),choices=[])	
		
		params.append([ppostproc,ppostprocargs])
		params.append([az,alt,phi])
		
		
		
	def get_postprocess_filt_options(self):
		if E2TomoFilterParticlesTask.preprocessor_cache == None:
			a = dump_processors_list()
			l = ["None"]
			for key in a.keys():
				if len(key) > 5 and key[:6] == "filter":
					vals = key.split(".")
					if len(vals) > 1:
						if vals[1] in ["lowpass","highpass"]:
							l.append(key)
							
			E2TomoFilterParticlesTask.preprocessor_cache = l
			 
		return E2TomoFilterParticlesTask.preprocessor_cache
	
	def check_params(self,params):
		error_message = []
		
		if params["filter"] != "None":
			if len(params["filterargs"]) == 0:
				error_message.append("If you supply a post processor for make3d, you have to supply one of the cutoff_abs, cutoff_freq, or cutoff_pixels parameters")
			else:
				s = params["filter"] + ":"
				s += params["filterargs"]
				p = parsemodopt(s)
				if p[0] == None:
					error_message.append("Error can't interpret the make3d post processor string (%s)" %(s))
				else:
					try:
						Processors.get(p[0], p[1])
						params["filter_processor"] = s
					except:
						error_message.append("Error, can't interpret parameters for the make3d post processor (%s)" %(s))
						vals = dump_processors_list()
						values = vals[p[0]]
						s = "The parameters for the %s processor are:"  %p[0]
						
						for i in xrange(1,len(values),3):
							s += " " + values[i] +","
						s = s[:-1] # get rid of the last column
						error_message.append(s)
						
		error_message.extend(self.check_name_param(params))		
		return error_message
	
	def check_name_param(self,params):
		error_message = []
		
		if not params.has_key("name"):
			error_message.append("You must supply a name for your filtered set")
		else:
			if params["name"] in self.get_previous_filtered_set_names():
				error_message.append("There is a previously filtered set with the name %s. Please choose another name" %params["name"])
		
		return error_message
	
	def on_form_ok(self,params):	
		if  params.has_key("filenames") and len(params["filenames"]) == 0:
			self.run_select_files_msg()
			return
		
		error_message = self.check_params(params)
		if len(error_message) >0: 
			self.show_error_message(error_message)
			return
		
		if params["alt"] != 0 or params["az"] != 0 or params["phi"] != 0:
			params["rotate"] = "%.2f,%.2f,%.2f" %(params["az"],params["alt"],params["phi"])

		if params.has_key("rotate") or params.has_key("filter_processor"):
			success,cmd = self.process_all(params)
			if not success:
				error("Command failed:"+cmd)
				return
		else:
			error("You have to supply a filter or a non zero rotation for any filtering to occur")
			return
		
		self.emit(QtCore.SIGNAL("task_idle"))
		self.form.close()
		self.form = None
	
		self.write_db_entries(params)	
	
	def get_previous_filtered_set_names(self):
		data_dict = EMProjectDataDict(tpr_ptcls_dict)
		db_map = data_dict.get_data_dict()
		
#		project_db = db_open_dict("bdb:project")
#		name = tpr_ptcls_dict
#		if not project_db.has_key(name):
#			return []
#		
#		db_map = project_db.get(name)
		previous_sets = []
		
		for root_name,dict in db_map.items():
			for filt,name in dict.items():
				if 	previous_sets.count(filt) == 0:
					previous_sets.append(filt)
					
		return previous_sets
	
	def convert_to_root(self,name):
		if self.name_map.has_key(name): return self.name_map[name]
		else:return name
	
	def output_names(self,params):
		'''
		Only works if you the params dictionary has the filenames and name keys 
		'''
		return ["bdb:tomo_particles#"+get_file_tag(self.convert_to_root(f))+"_"+params["name"] for f in params["filenames"]]
		
	def process_all(self,params):
		
		outnames = self.output_names(params)
		
		progress = QtGui.QProgressDialog("Processing files...", "Abort", 0, len(params["filenames"]),None)
		progress.show()
	
		i = 0
		for i,name in enumerate(params["filenames"]):
			cmd = "e2proc3d.py"
 			cmd += " "+name
 			cmd += " "+outnames[i]
 			if params.has_key("filter_processor"):
 				cmd += " --process="+params["filter_processor"]
 			if params.has_key("rotate"):
 				cmd += " --rot="+params["rotate"]
 			success = (os.system(cmd) in (0,12))
 			if not success:
 				progress.close()
 				return False,cmd
 			else:
 				progress.setValue(i+1)
 				get_application().processEvents()
		
		progress.close()
		
		self.save_to_filt_ptcls_map(params, outnames)
		return True,"Success"
	
	def save_to_filt_ptcls_map(self,params,outnames):
		data_dict = EMProjectDataDict(tpr_ptcls_dict)
		db_map = data_dict.get_data_dict()
		
#		project_db = db_open_dict("")
#		project_list = tpr_ptcls_dict
#		db_map = project_db.get(project_list,dfl={})
		
		for i,name in enumerate(params["filenames"]):
			real_name = self.convert_to_root(name)
			if db_map.has_key(real_name):
				d = db_map[real_name]
				d[params["name"]] = outnames[i]
				db_map[real_name] = d
			else:
				d = {}
				d[params["name"]] = outnames[i]
				db_map[real_name] = d
		data_dict.update(db_map)

class E2TomoScaleClipTask(E2TomoFilterParticlesTask):
	'''Scale and clipping'''
	def __init__(self,ptcls_list=[],name_map={}):
		E2TomoFilterParticlesTask.__init__(self,ptcls_list,name_map)
		self.form_db_name = "bdb:emform.tomo.filter_scale_clip"
	
	def add_filt_params(self,params):
		'''
		'''
		db = db_open_dict(self.form_db_name)
		scale = ParamDef(name="scale",vartype="float",desc_short="Scale pixel width",desc_long="Scales the input image pixel spacing by the given amount",property=None,defaultunits=db.get("scale",dfl=1.0),choices=None)
		clip = ParamDef(name="clip",vartype="int",desc_short="Clip to",desc_long="Clipping to be applied to scaled images",property=None,defaultunits=db.get("clip",dfl=0),choices=None)

		params.append([scale,clip])
		
	def check_params(self,params):
		error_message = []
		
		if not params.has_key("scale"):
			error_message.append("Please supply the scale the argument")
		elif params["scale"] <= 0:
			error_message.append("Scale has to be greater than zero")
			
		if not params.has_key("clip"):
			error_message.append("Please supply the clip the argument")
		elif params["clip"] <= 0:
			error_message.append("Clip has to be greater than zero")
						
		error_message.extend(self.check_name_param(params))		
		return error_message
	
	def on_form_ok(self,params):	
		if  params.has_key("filenames") and len(params["filenames"]) == 0:
			self.run_select_files_msg()
			return
		
		error_message = self.check_params(params)
		if len(error_message) >0: 
			self.show_error_message(error_message)
			return
	
		success,cmd = self.process_all(params)
		if not success:
			error("Command failed:"+cmd)
			return
		
		self.emit(QtCore.SIGNAL("task_idle"))
		self.form.close()
		self.form = None
	
		self.write_db_entries(params)	
	
	def process_all(self,params):
		
		outnames = self.output_names(params)
		
		progress = QtGui.QProgressDialog("Processing files...", "Abort", 0, len(params["filenames"]),None)
		progress.show()
	
		i = 0
		for i,name in enumerate(params["filenames"]):
			cmd = "e2proc3d.py"
 			cmd += " "+name
 			cmd += " "+outnames[i]
 			cmd += " --process=xform.scale:scale=%s:clip=%s" %(params["scale"],params["clip"])
 			success = (os.system(cmd) in (0,12))
 			if not success:
 				progress.close()
 				return False,cmd
 			else:
 				progress.setValue(i+1)
 				get_application().processEvents()
		
		progress.close()
		
		
		self.save_to_filt_ptcls_map(params, outnames)

		return True,"Success"


class E2TomoMaskTask(E2TomoFilterParticlesTask):
	'''Use this tool for masking your data. All voxels beyond the given radius will be set to 0.'''
	def __init__(self,ptcls_list=[],name_map={}):
		E2TomoFilterParticlesTask.__init__(self,ptcls_list,name_map)
		self.form_db_name = "bdb:emform.tomo.filter_mask"
	
	def add_filt_params(self,params):
		'''
		'''
		db = db_open_dict(self.form_db_name)
		mask = ParamDef(name="mask",vartype="int",desc_short="Mask radius",desc_long="The radius of the masking operation",property=None,defaultunits=db.get("mask",dfl=0),choices=None)

		params.append(mask)
		
	def check_params(self,params):
		error_message = []
		
		if not params.has_key("mask"):
			error_message.append("Please supply the mask argument")
		elif params["mask"] <= 0:
			error_message.append("mask has to be greater than zero")
						
		error_message.extend(self.check_name_param(params))		
		return error_message
	
	def on_form_ok(self,params):	
		if  params.has_key("filenames") and len(params["filenames"]) == 0:
			self.run_select_files_msg()
			return
		
		error_message = self.check_params(params)
		if len(error_message) >0: 
			self.show_error_message(error_message)
			return
	
		success,cmd = self.process_all(params)
		if not success:
			error("Command failed:"+cmd)
			return
		
		self.emit(QtCore.SIGNAL("task_idle"))
		self.form.close()
		self.form = None
	
		self.write_db_entries(params)	
	
	def process_all(self,params):
		
		outnames = self.output_names(params)
		
		progress = QtGui.QProgressDialog("Processing files...", "Abort", 0, len(params["filenames"]),None)
		progress.show()
	
		i = 0
		for i,name in enumerate(params["filenames"]):
			cmd = "e2proc3d.py"
 			cmd += " "+name
 			cmd += " "+outnames[i]
 			cmd += " --process=mask.sharp:outer_radius=%s" %(params["mask"])
 			success = (os.system(cmd) in (0,12))
 			if not success:
 				progress.close()
 				return False,cmd
 			else:
 				progress.setValue(i+1)
 				get_application().processEvents()
		
		progress.close()
		
		self.save_to_filt_ptcls_map(params,outnames)
		return True,"Success"
	
	

		
class E2TomoNormalizeInvertTask(E2TomoFilterParticlesTask):
	'''Use this tool inverting and/or normalizing your data. If both operations are chosen then inversion is performed first.'''
	
	def __init__(self,ptcls_list=[],name_map={}):
		E2TomoFilterParticlesTask.__init__(self,ptcls_list,name_map)
		self.form_db_name = "bdb:emform.tomo.invert_norm"
	
	def add_filt_params(self,params):
		'''
		'''
		db = db_open_dict(self.form_db_name)
		pinv = ParamDef(name="invert",vartype="boolean",desc_short="Invert",desc_long="Invert pixel intensities",property=None,defaultunits=db.get("invertoutput",dfl=False),choices=None)
		pn =  ParamDef(name="normproc",vartype="string",desc_short="Normalize",desc_long="Normalization method",property=None,defaultunits=db.get("normproc",dfl="normalize.edgemean"),choices=self.get_norm_proc_list())
		
		params.append([pinv,pn])
	
	def get_norm_proc_list(self):
		return ["None","normalize","normalize.circlemean","normalize.edgemean","normalize.unitlen","normalize.unitsum"]
	
	def check_params(self,params):
		error_message = []
		
		if params["invert"] == False and params["normproc"] == "None":
			error_message.append("Atleast one of the invert or normalization options must be chosen")
						
		error_message.extend(self.check_name_param(params))		
		return error_message
	
	def on_form_ok(self,params):	
		if  params.has_key("filenames") and len(params["filenames"]) == 0:
			self.run_select_files_msg()
			return
		
		error_message = self.check_params(params)
		if len(error_message) >0: 
			self.show_error_message(error_message)
			return
	
		success,cmd = self.process_all(params)
		if not success:
			error("Command failed:"+cmd)
			return
		
		self.emit(QtCore.SIGNAL("task_idle"))
		self.form.close()
		self.form = None
	
		self.write_db_entries(params)	
	
	def process_all(self,params):
		
		outnames = self.output_names(params)
		
		progress = QtGui.QProgressDialog("Processing files...", "Abort", 0, len(params["filenames"]),None)
		progress.show()
	
		i = 0
		for i,name in enumerate(params["filenames"]):
			cmd = "e2proc3d.py"
 			cmd += " "+name
 			cmd += " "+outnames[i]
 			if params["invert"]:
 				cmd += " --mult=-1"
 			if params["normproc"] != "None":
 				cmd += " --process=%s" %(params["normproc"])
 			success = (os.system(cmd) in (0,12))
 			if not success:
 				progress.close()
 				return False,cmd
 			else:
 				progress.setValue(i+1)
 				get_application().processEvents()
		
		progress.close()
		
		self.save_to_filt_ptcls_map(params,outnames)
		return True,"Success"


class EMTomoChooseFilteredPtclsForFiltTask(EMBaseTomoChooseFilteredPtclsTask):
	"""Choose the data you wish to filter""" 
	def __init__(self,task_type=E2TomoFilterParticlesTask):
		EMBaseTomoChooseFilteredPtclsTask.__init__(self)
		self.form_db_name ="bdb:tomo.choose.filtered.forfilt"
		self.task_type = task_type

	def on_form_ok(self,params):
		if not params.has_key("tomo_filt_choice") or params["tomo_filt_choice"] == None:
			error("Please choose some data")
			return
		choice = params["tomo_filt_choice"]
		
		task = self.task_type(self.particles_map[self.particles_name_map[choice]],self.name_map)
		self.emit(QtCore.SIGNAL("replace_task"),task,"Filter Tomo Particles")
		self.form.close()
		self.form = None
		
		self.write_db_entries(params)

class EMTomoBootStapChoosePtclsTask(EMBaseTomoChooseFilteredPtclsTask):
	"""Choose the particle set you wish to use to generate the bootstrapped probe. The sets available will include the raw particles and any filtered sets you have generated.""" 

	def __init__(self):
		EMBaseTomoChooseFilteredPtclsTask.__init__(self)
		self.form_db_name ="bdb:tomo.choose.forbootstraptomo"

	def on_form_ok(self,params):
		if not params.has_key("tomo_filt_choice") or params["tomo_filt_choice"] == None:
			error("Please choose some data")
			return
		choice = params["tomo_filt_choice"]
		task = EMTomoBootstrapTask(self.particles_map[self.particles_name_map[choice]],self.name_map)
		self.emit(QtCore.SIGNAL("replace_task"),task,"Filter Tomo Particles")
		self.form.close()
		self.form = None
		
		self.write_db_entries(params)

class EMTomoAlignParams:
	'''
	A class that get parameters commonly used by alignment based programs
	'''

class EMTomoBootstrapTask(WorkFlowTask):
	'''Use this task for running e2tomoaverage.py from the workflow for generating a bootstrapped probe'''
	
	# written by Grant Tang
	documentation_string = "This is useful information about this task."

	def __init__(self,ptcls_list=[],name_map={}):
		WorkFlowTask.__init__(self)
		self.window_title = "Tomohunter Input Form"
		self.preferred_size = (640,480)
		self.form_db_name = "bdb:emform.tomohunter"
		self.ptcls_list = ptcls_list
		self.name_map = name_map
		
	def run_form(self):
		self.form = EMTableFormWidget(self.get_params())
		self.form.resize(*self.preferred_size)
		self.form.setWindowTitle(self.window_title)
		get_application().show_specific(self.form)
		QtCore.QObject.connect(self.form,QtCore.SIGNAL("emform_ok"),self.on_form_ok)
		QtCore.QObject.connect(self.form,QtCore.SIGNAL("emform_cancel"),self.on_form_cancel)
		QtCore.QObject.connect(self.form,QtCore.SIGNAL("emform_close"),self.on_form_close)
		QtCore.QObject.connect(self.form,QtCore.SIGNAL("display_file"),self.on_display_file)
		
	def get_params(self):
		table_params = []
		params = []
		db = db_open_dict(self.form_db_name)
		
		self.ptcl_table_tool = EMTomoPtclReportTool(title="Particles",name="targetimage")
		
		params.append(ParamDef(name="blurb",vartype="text",desc_short="SPR",desc_long="Information regarding this task",property=None,defaultunits=self.__doc__,choices=None))
		nsoln = ParamDef(name="nsoln",vartype="int",desc_short="Number of solutions",desc_long="number of solution",property=None,defaultunits=db.get("nsoln",10),choices=None)
		params.append(self.ptcl_table_tool.get_particle_table_with_ptcls(self.ptcls_list))
		params.append(nsoln)
		pparallel = ParamDef(name="parallel",vartype="string",desc_short="Parallel",desc_long="Parallel arguments (advanced). Leave blank if unsure",property=None,defaultunits=db.get("parallel",dfl=""),choices=None)
		params.append(pparallel)
		pshrink = ParamDef(name="shrink",vartype="int",desc_short="Shrink",desc_long="Shrink the data at various stages, for speed purposes but at the expense of resolution",property=None,defaultunits=db.get("shrink",dfl=4),choices=[])
		params.append(pshrink)
		
		table_params.append(["Main",params])
		
		advanced_params = []
		data = dump_aligners_list()
		data_3d = {}
		data_3d["rt.3d.grid"] = data["rt.3d.grid"]
		data_3d["rt.3d.sphere"] = data["rt.3d.sphere"]
		
		pstrategy = EMEmanStrategyWidget(data_3d,name="align",desc_short="Main Alignment Strategy",desc_long="Choose an alignment strategy",defaultunits="rt.3d.grid")
		advanced_params.append(pstrategy)
		
		pcmp = EMEmanStrategyWidget(dump_cmps_list(),name="cmp",desc_short="Comparison Method",desc_long="Supply your comparator",defaultunits="dot.tomo")
		advanced_params.append(pcmp)
		
		
		data_r3d = {}
		data_r3d["refine.3d"] = data["refine.3d"]
		data_r3d["None"] = ["Choose this to stop the refinement aligner from being used"]
		prstrategy = EMEmanStrategyWidget(data_r3d,name="ralign",desc_short="Refinement Alignment Strategy",desc_long="Choose a refine alignment strategy. Choose None to disable this",defaultunits="None")
		advanced_params.append(prstrategy)
		
		proc_data = dump_processors_list()
		proc_data_d = {}
		for key in proc_data.keys():
			if len(key) >= 7 and key[:7] == "filter.":
				proc_data_d[key] = proc_data[key]
				
		proc_data_d["None"] = ["Choose this to stop filtering from occuring"]

		if len(proc_data_d) > 0:
			pproc_str = EMEmanStrategyWidget(proc_data_d,name="filter",desc_short="Filter",desc_long="Choose",defaultunits="None")
			advanced_params.append(pproc_str)
		
		table_params.append(["Advanced",advanced_params])
		#db_close_dict("bdb:project")
		return table_params

	def write_db_entry(self,key,value):
		WorkFlowTask.write_db_entry(self,key,value)
	
	def check_params(self,params):
		error_msg = []
		if len(params["targetimage"]) == 0: error_msg.append("Please choose at leaset one particle file")
		if params.has_key("shrink") and params["shrink"] <= 1:
			error_msg.append("If you supply the shrink argument it must be greater than 1. To avoid shrinking leave it blank.")
		return error_msg
	
	def on_form_ok(self,params):
		
		error_message = self.check_params(params)
		if len(error_message):
			self.show_error_message(error_message)
			return
		self.write_db_entries(params) # will only write filenames
		options = EmptyObject()
		string_args = ["align","cmp","aligncmp"]
		options.filenames = params['targetimage']
		options.align = params['align']
#		options.n = params['n']
		options.nsoln = params['nsoln']
		
		options.cmp = params["cmp"]
		options.aligncmp = params["cmp"]
		
		if params["ralign"] != "None":
			string_args.extend(["ralign","raligncmp"])
			options.ralign = params['ralign']
			options.raligncmp = params["cmp"]
			
		if params.has_key("parallel") and len(params["parallel"]) > 0:
			string_args.append('parallel')
			options.parallel = params['parallel']
		
		if params.has_key("shrink"):
			string_args.append('shrink')
			options.shrink = params['shrink']
			
		if params.has_key("filter"):
			string_args.append('filter')
			options.filter = params['filter']
			
			
		bool_args = []
		additional_args = ["--dbls=%s" %tpr_probes_dict, "--bootstrap"]
		temp_file_name = "e2tomoaverage_stdout.txt"
		self.spawn_single_task('e2tomoaverage.py',options,string_args,bool_args,additional_args,temp_file_name)
		self.emit(QtCore.SIGNAL("task_idle"))
		self.form.close()
		self.form = None



class EMTomohunterTask(WorkFlowTask):
	'''Use this task for running e2tomohunter.py from the workflow'''
	
	# written by Grant Tang
	documentation_string = "This is useful information about this task."

	def __init__(self,ptcls_list=[],name_map={}):
		WorkFlowTask.__init__(self)
		self.window_title = "Tomohunter Input Form"
		self.preferred_size = (640,480)
		self.form_db_name = "bdb:emform.tomohunter"
		self.ptcls_list = ptcls_list
		self.name_map = name_map
		
	def run_form(self):
		self.form = EMTableFormWidget(self.get_params())
		self.form.resize(*self.preferred_size)
		self.form.setWindowTitle(self.window_title)
		get_application().show_specific(self.form)
		QtCore.QObject.connect(self.form,QtCore.SIGNAL("emform_ok"),self.on_form_ok)
		QtCore.QObject.connect(self.form,QtCore.SIGNAL("emform_cancel"),self.on_form_cancel)
		QtCore.QObject.connect(self.form,QtCore.SIGNAL("emform_close"),self.on_form_close)
		QtCore.QObject.connect(self.form,QtCore.SIGNAL("display_file"),self.on_display_file)
		
	def get_params(self):
		table_params = []
		params = []
		db = db_open_dict(self.form_db_name)
		
		self.ptcl_table_tool = EMTomoPtclReportTool(title="Particles",name="targetimage")
		self.probe_tool = EMTomoPtclReportTool(tpr_probes_dict,"Probe","probeimage")
		
		params.append(ParamDef(name="blurb",vartype="text",desc_short="SPR",desc_long="Information regarding this task",property=None,defaultunits=self.__doc__,choices=None))
		nsoln = ParamDef(name="nsoln",vartype="int",desc_short="Number of solutions",desc_long="number of solution",property=None,defaultunits=db.get("nsoln",10),choices=None)
		params.append([self.probe_tool.get_particle_table(),self.ptcl_table_tool.get_particle_table_with_ptcls(self.ptcls_list)])
		params.append(nsoln)
		pparallel = ParamDef(name="parallel",vartype="string",desc_short="Parallel",desc_long="Parallel arguments (advanced). Leave blank if unsure",property=None,defaultunits=db.get("parallel",dfl=""),choices=None)
		params.append(pparallel)
		pshrink = ParamDef(name="shrink",vartype="int",desc_short="Shrink",desc_long="Shrink the data at various stages, for speed purposes but at the expense of resolution",property=None,defaultunits=db.get("shrink",dfl=4),choices=[])
		params.append(pshrink)
		
		table_params.append(["Main",params])
		
		advanced_params = []
		data = dump_aligners_list()
		data_3d = {}
		data_3d["rt.3d.grid"] = data["rt.3d.grid"]
		data_3d["rt.3d.sphere"] = data["rt.3d.sphere"]
		
		pstrategy = EMEmanStrategyWidget(data_3d,name="align",desc_short="Main Alignment Strategy",desc_long="Choose an alignment strategy",defaultunits="rt.3d.grid")
		advanced_params.append(pstrategy)
		
		pcmp = EMEmanStrategyWidget(dump_cmps_list(),name="cmp",desc_short="Comparison Method",desc_long="Supply your comparator",defaultunits="dot.tomo")
		advanced_params.append(pcmp)
	
		data_r3d = {}
		data_r3d["refine.3d"] = data["refine.3d"]
		data_r3d["None"] = ["Choose this to stop the refinement aligner from being used"]
		prstrategy = EMEmanStrategyWidget(data_r3d,name="ralign",desc_short="Refinement Alignment Strategy",desc_long="Choose a refine alignment strategy. Choose None to disable this",defaultunits="None")
		advanced_params.append(prstrategy)
		
		proc_data = dump_processors_list()
		proc_data_d = {}
		for key in proc_data.keys():
			if len(key) >= 7 and key[:7] == "filter.":
				proc_data_d[key] = proc_data[key]
				
		proc_data_d["None"] = ["Choose this to stop filtering from occuring"]

		if len(proc_data_d) > 0:
			pproc_str = EMEmanStrategyWidget(proc_data_d,name="filter",desc_short="Filter",desc_long="Choose",defaultunits="None")
			advanced_params.append(pproc_str)
	
		table_params.append(["Advanced",advanced_params])
		#db_close_dict("bdb:project")
		return table_params

	def write_db_entry(self,key,value):
		WorkFlowTask.write_db_entry(self,key,value)
	
	def check_params(self,params):
		error_msg = []
		if len(params["targetimage"]) == 0: error_msg.append("Please choose at leaset one particle file")
		if len(params["probeimage"]) != 1: error_msg.append("Please choose a single probe file to proceed")
		if params.has_key("shrink") and params["shrink"] <= 1:
			error_msg.append("If you supply the shrink argument it must be greater than 1. To avoid shrinking leave it blank.")
		return error_msg
	
	def on_form_ok(self,params):
		
		error_message = self.check_params(params)
		if len(error_message):
			self.show_error_message(error_message)
			return
		self.write_db_entries(params) # will only write filenames
		options = EmptyObject()
		string_args = ["align","probe","cmp","aligncmp"]
		options.filenames = params['targetimage']
		options.align = params['align']
		options.probe = params['probeimage'][0]
#		options.n = params['n']
		options.nsoln = params['nsoln']
		
		options.cmp = params["cmp"]
		options.aligncmp = params["cmp"]
		
		if params["ralign"] != "None":
			string_args.append("ralign","raligncmp")
			options.ralign = params['ralign']
			options.raligncmp = params["cmp"]
			
		if params.has_key("parallel") and len(params["parallel"]) > 0:
			string_args.append('parallel')
			options.parallel = params['parallel']
			
		if params.has_key("shrink"):
			string_args.append('shrink')
			options.shrink = params['shrink']
			
		if params.has_key("filter"):
			string_args.append('filter')
			options.filter = params['filter']
			
		bool_args = []
		additional_args = ["--dbls=%s" %tpr_ptcls_ali_dict]
		temp_file_name = "e2tomohunter_stdout.txt"
		self.spawn_single_task('e2tomohunter.py',options,string_args,bool_args,additional_args,temp_file_name)
		self.emit(QtCore.SIGNAL("task_idle"))
		self.form.close()
		self.form = None


class EMTomoChooseTomoHunterPtclsTask(EMBaseTomoChooseFilteredPtclsTask):
	"""Choose the particle set you wish to use for performing alignments. The sets available will include the raw particles and any filtered sets you have generated.""" 

	def __init__(self):
		EMBaseTomoChooseFilteredPtclsTask.__init__(self)
		self.form_db_name ="bdb:tomo.choose.fortomohunter"

	def on_form_ok(self,params):
		if not params.has_key("tomo_filt_choice") or params["tomo_filt_choice"] == None:
			error("Please choose some data")
			return
		choice = params["tomo_filt_choice"]
		print "tomo hunter chose"
		task = EMTomohunterTask(self.particles_map[self.particles_name_map[choice]],self.name_map)
		self.emit(QtCore.SIGNAL("replace_task"),task,"Filter Tomo Particles")
		self.form.close()
		self.form = None
		
		self.write_db_entries(params)

class E2TomoAverageChooseAliTask(WorkFlowTask):
	"""Choose data for generating an average based on the probe which you aligned them too"""
	def __init__(self):
		WorkFlowTask.__init__(self)
		self.window_title = "Choose Alignment Set"
		self.form_db_name = "bdb:emform.tomo.choose_ali_set"
		self.preferred_size = (480,240)
		self.selection_map = {}
		self.ali_probe_map = {}
	def get_params(self):
		params = []
		
		EMProjectListCleanup.clean_up_ali_params()
		
		project_list = tpr_ptcls_ali_dict
		db = db_open_dict("bdb:project",ro=True)
		db_map = db.get(project_list,dfl={})
		
		probes = []
		probes_data = {}
		self.ali_probe_map = {}
		for key,dct in db_map.items():
			for probe,alis in dct.items():
				if probe not in probes:
					probes.append(probe)
					probes_data[probe] = 1
					self.ali_probe_map[probe] = [key]
				else:
					probes_data[probe] += 1
					self.ali_probe_map[probe].append(key)
		
		db = db_open_dict(self.form_db_name)
		params.append(ParamDef(name="blurb",vartype="text",desc_short="",desc_long="",property=None,defaultunits=str(self.__doc__),choices=None))
		
		self.selection_map = {}
		choices = []
		for key,value in probes_data.items():
			s = get_file_tag(key) +" ("+str(value)+")"
			self.selection_map[s] = key
			choices.append(s)
		
		if len(probes) > 0:
			params.append(ParamDef(name="probe_choice",vartype="choice",desc_long="Choose probe corresponding to the alignment",desc_short="Choose alignemt set based on probe",property=None,defaultunits=db.get("probe_choice",dfl=""),choices=choices))
		return params
	
	
	def on_form_ok(self,params):
		if not params.has_key("probe_choice"): return	
		if  params.has_key("probe_choice") and len(params["probe_choice"]) == 0:
			self.run_select_files_msg()
			return
		
		self.write_db_entries(params)
		
		task = E2TomoGenerateAverageTask(self.ali_probe_map[self.selection_map[params["probe_choice"]]],self.selection_map[params["probe_choice"]])
		self.emit(QtCore.SIGNAL("replace_task"),task,"Generate Tomo Average")
		self.emit(QtCore.SIGNAL("task_idle"))
		self.form.close()
		self.form = None
		
class EMTomoGenerateAverageChooseDataTask(WorkFlowTask):
	'''In this form you are choosing two things. The first thing required is for you to choose the alignment parameters, which are associated with a particular probe and a particular particle set. After this you must choose which particle set you want to combine into an average.'''
	def __init__(self):
		WorkFlowTask.__init__(self)
		self.window_title = "Choose Alignment Data"
		self.form_db_name = "bdb:emform.tomo.genave.choose"
		self.preferred_size = (480,240)
		
	def get_params(self):
		db = db_open_dict(self.form_db_name)
		tls = EMProbeAliTools()
		self.probe_set_map,self.probe_and_ali,self.probe_name_map = tls.accrue_data()
		
		params = []
		params.append(ParamDef(name="blurb",vartype="text",desc_short="",desc_long="",property=None,defaultunits=self.__doc__,choices=None))
		if len(self.probe_and_ali) != 0:
			params.append(ParamDef(name="probe_ali_data", vartype="dict",desc_short="Probe and alignment parameters",desc_long="Select the probe and corresponding alignment set for the purpose of generating an average. This equates to choosing which alignment you want to use as the basis for generating an average", property=None, defaultunits="",choices=self.probe_and_ali  ))
		
		ptcl_opts = EMPartSetOptions(tpr_ptcls_dict)
		self.particles_map, self.particles_name_map, choices, self.name_map = ptcl_opts.get_particle_options()
		
		if len(choices) > 0:
			params.append(ParamDef(name="ptcl_choice",vartype="choice",desc_long="Choose from the filtered tomogram particles",desc_short="Choose data that will form the average",property=None,defaultunits=db.get("ptcl_choice",dfl=""),choices=choices))
		
		return params

	def on_form_ok(self,params):
		if not params.has_key("ptcl_choice") or not params["ptcl_choice"]:
			error("Please choose a particle set")
			return
		
		if not params.has_key("probe_ali_data") or not params["probe_ali_data"]:
			error("Please choose probe/ali data")
			return
		
		probe_tag = params["probe_ali_data"]
		probe = self.probe_name_map[probe_tag]
		ali_set = params["probe_ali_data_selection"]
		ptcls_set = self.particles_map[self.particles_name_map[params["ptcl_choice"]]]
		
		base_set = self.probe_set_map[probe_tag][ali_set]
		ptcl_base_set = [self.name_map[name] for name in base_set]
		
		final_set = []
		for name in ptcls_set:
			if self.name_map[name] in ptcl_base_set:
				final_set.append(name)
				
		task = E2TomoGenerateAverageTask(final_set,probe,ali_set)
		self.emit(QtCore.SIGNAL("replace_task"),task,"Filter Tomo Particles")
		self.form.close()
		self.form = None
		self.write_db_entries(params)

class E2TomoGenerateAverageTask(WorkFlowTask):	
	"""This task is for generating averages of your tomographic particles. Choose the particles you want to combine into an average, choose a name for the average, and hit OK. Have a look in the 'Particle Averages' table once the task is completed to see the results."""
	def __init__(self,ptcls_list=[],probe="",ali_set=""):
		WorkFlowTask.__init__(self)
		self.window_title = "Generate Tomo Average"
		self.form_db_name = "bdb:emform.tomo.generate_average"
		self.ptcls_list = ptcls_list
		self.probe = probe
		self.ali_set = ali_set
#	def __del__(self):
#		print "output task dies"
	
	def get_params(self):
		params = []

		from emform import EM3DFileTable,EMFileTable
		table = EM3DFileTable(self.ptcls_list,desc_short="Tomogram Particles",desc_long="")
#		context_menu_data = EMRawDataReportTask.ProjectListContextMenu(self.project_list)
#		table.add_context_menu_data(context_menu_data)
#		table.add_button_data(EMRawDataReportTask.ProjectAddRawDataButton(table,context_menu_data))
	#	table.insert_column_data(1,EMFileTable.EMColumnData("Particles On Disk",ParticleReportTask.get_num_ptcls,"Particles currently stored on disk that are associated with this image"))
		table.insert_column_data(1,EMFileTable.EMColumnData("Particle Dims",EMParticleReportTask.get_particle_dims,"The dimensions of the particles that are stored on disk"))
		
		d = EMTomoPtclAlignmentReportTask.AlignmentColumn(self.probe,self.ali_set)
		table.insert_column_data(0,EMFileTable.EMColumnData(get_file_tag(self.probe),d.get_ali_params,"Alignment parameters"))
		
		db = db_open_dict(self.form_db_name)
	 	pname = ParamDef(name="ave_name",vartype="string",desc_short="Name Of Average",desc_long="What you want to call this average. Leave out file types (such as hdf,bdb etc).",property=None,defaultunits=db.get("ave_name",dfl="average"),choices=None)
		
		params.append(ParamDef(name="blurb",vartype="text",desc_short="",desc_long="",property=None,defaultunits=self.__doc__,choices=None))
		params.append(table)  
		params.append(pname)
		return params
	

	def check_params(self,params):
		e = []
		if not params.has_key("ave_name"):
			e.append("you must specify the name of the average")
		else:
			name = params["ave_name"]
			real_name = "bdb:tomo_averages#"+name
			if db_check_dict(real_name):
				e.append("The file %s already exists. Please choose another name" %real_name)
			else:
				params["out_name"] = real_name
		
		return e
	
	def on_form_ok(self,params):	
		if  params.has_key("filenames") and len(params["filenames"]) == 0:
			self.run_select_files_msg()
			return
		
		error_msg = self.check_params(params)
		if len(error_msg) > 0:
			error(error_msg)
			return
		
		options = EmptyObject()
		options.avgout = params["out_name"]
		options.filenames = params["filenames"]
		options.dbls = tpr_ptcl_ave_dict
		options.aliset = self.ali_set
		options.probe = self.probe
		
		string_args = ["avgout","dbls","probe","aliset"]
		bool_args = []
		additional_args = []
		temp_file_name = "e2tomohunter_average_stdout.txt"
		self.spawn_single_task("e2tomohunter.py",options,string_args,bool_args,additional_args,temp_file_name)
		self.emit(QtCore.SIGNAL("task_idle"))
		self.form.close()
		self.form = None
		
		self.write_db_entries(params)
		
		
class EMProbeAliTools:
	'''Used to figure out which probe was aligned to which set, etc. Their are 3 dimensions to the decision make processes involved here, making it somewhat complicated'''
	def __init__(self):
		pass
	
	def accrue_data(self):
		EMProjectListCleanup.clean_up_ali_params()
		
		set_map = {}
		
		ptcls_db = EMProjectDataDict(tpr_ptcls_dict)
		sets = ptcls_db.get_data_dict()
		
		for ptcl,map in sets.items():
			for filt,filt_ptcl in map.items():
				set_map[filt_ptcl] = filt
				
			set_map[ptcl] = "Particles"
		
		
		probe_db = EMProjectDataDict(tpr_probes_dict)
		probes = probe_db.keys()
		project_db = db_open_dict("bdb:project")
		ali_dict = project_db.get(tpr_ptcls_ali_dict,dfl={})
		
		probe_set_map = {}
		
		for probe in probes:
			tag = get_file_tag(probe)
			probe_set_map[tag] = {}
		
		probe_and_ali = {}
		probe_name_map = {}
		
		
		for filt_ptcl,map in ali_dict.items():
			for probe,t in map.items():
				if not set_map.has_key(filt_ptcl): continue
				tag = get_file_tag(probe)
				filt = set_map[filt_ptcl]
				if not probe_set_map[tag].has_key(filt):
					probe_set_map[tag][filt] = [filt_ptcl]
				else:
					probe_set_map[tag][filt].append(filt_ptcl)
				
				if not probe_and_ali.has_key(tag):
					probe_and_ali[tag] = [filt]
					probe_name_map[tag] = probe
				elif probe_and_ali[tag].count(filt) == 0:
					probe_and_ali[tag].append(filt)
		
		return probe_set_map,probe_and_ali,probe_name_map
					
			
			
		
